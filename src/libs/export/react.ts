export interface ExportOptions {
	styling: 'tailwind' | 'css-modules' | 'styled-components' | 'inline';
	typescript: boolean;
	includeComments?: boolean;
}

export interface Design {
	objects: any[];
	styles?: Record<string, string>;
	colorPalette?: string[];
}

/**
 * Export design to React component code
 */
export async function exportToReact(design: Design, options: ExportOptions): Promise<string> {
	const imports = generateImports(options);
	const component = generateComponentCode(design, options);

	return `${imports}\n\n${component}`;
}

/**
 * Generate import statements based on options
 */
export function generateImports(options: ExportOptions): string {
	const imports: string[] = [];

	if (options.typescript) {
		imports.push("import React, { FC } from 'react';");
	} else {
		imports.push("import React from 'react';");
	}

	if (options.styling === 'styled-components') {
		imports.push("import styled from 'styled-components';");
	}

	return imports.join('\n');
}

/**
 * Generate React component code from design
 */
export function generateComponentCode(design: Design, options: ExportOptions): string {
	const { typescript, styling, includeComments } = options;

	const componentName = 'GeneratedComponent';
	const typeAnnotation = typescript ? ': FC' : '';

	const elements = design.objects.map((obj, index) => {
		return generateElement(obj, index, styling);
	});

	const componentBody = `
  return (
    <div className="generated-container">
      ${elements.join('\n      ')}
    </div>
  );`;

	const component = `${includeComments ? '// Generated by AI UI Generator\n' : ''}export const ${componentName}${typeAnnotation} = () => {${componentBody}
};`;

	return component;
}

/**
 * Generate a single element from a design object
 */
function generateElement(obj: any, index: number, styling: string): string {
	const { type, left, top, width, height, fill, text, fontSize } = obj;

	if (type === 'rect') {
		const styles = generateStyles({ left, top, width, height, backgroundColor: fill }, styling);
		return `<div${styles} />`;
	}

	if (type === 'textbox' || type === 'text') {
		const styles = generateStyles({ left, top, fontSize, color: fill }, styling);
		return `<div${styles}>${text || ''}</div>`;
	}

	if (type === 'circle') {
		const styles = generateStyles(
			{
				left,
				top,
				width: obj.radius ? obj.radius * 2 : width,
				height: obj.radius ? obj.radius * 2 : height,
				borderRadius: '50%',
				backgroundColor: fill,
			},
			styling
		);
		return `<div${styles} />`;
	}

	// Default fallback
	return `<div key="${index}" />`;
}

/**
 * Generate style attributes based on styling option
 */
function generateStyles(styles: Record<string, any>, styling: string): string {
	if (styling === 'tailwind') {
		return ` className="${generateTailwindClasses(styles)}"`;
	}

	if (styling === 'inline') {
		const styleString = Object.entries(styles)
			.map(([key, value]) => `${key}: ${typeof value === 'number' ? `${value}px` : `'${value}'`}`)
			.join(', ');
		return ` style={{ ${styleString} }}`;
	}

	// Default to className
	return ' className="element"';
}

/**
 * Convert styles to Tailwind classes
 */
function generateTailwindClasses(styles: Record<string, any>): string {
	const classes: string[] = [];

	if (styles.backgroundColor) {
		// Map common colors to Tailwind
		const colorMap: Record<string, string> = {
			'#3B82F6': 'bg-blue-500',
			'#10B981': 'bg-green-500',
			'#EF4444': 'bg-red-500',
			'#F59E0B': 'bg-amber-500',
			'#8B5CF6': 'bg-purple-500',
			'#EC4899': 'bg-pink-500',
		};
		classes.push(colorMap[styles.backgroundColor] || 'bg-gray-500');
	}

	if (styles.color) {
		const colorMap: Record<string, string> = {
			'#FFFFFF': 'text-white',
			'#000000': 'text-black',
			'#3B82F6': 'text-blue-500',
		};
		classes.push(colorMap[styles.color] || 'text-gray-900');
	}

	if (styles.fontSize) {
		if (styles.fontSize <= 12) classes.push('text-xs');
		else if (styles.fontSize <= 14) classes.push('text-sm');
		else if (styles.fontSize <= 16) classes.push('text-base');
		else if (styles.fontSize <= 18) classes.push('text-lg');
		else if (styles.fontSize <= 24) classes.push('text-xl');
		else classes.push('text-2xl');
	}

	if (styles.borderRadius === '50%') {
		classes.push('rounded-full');
	} else if (styles.borderRadius) {
		classes.push('rounded');
	}

	// Add positioning classes
	classes.push('absolute');

	return classes.join(' ');
}
