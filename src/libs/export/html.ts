/**
 * HTML/CSS Code Export
 * Convert Fabric.js designs to semantic HTML and CSS
 */

import { ExportedCode, ExportOptions } from '../../types/aiui';

import { cssObjectToString, fabricToCSS, formatCode, generateId, kebabToCamel } from './utils';

/**
 * Generate semantic HTML5 from Fabric.js objects
 */
const generateHTML = (objects: any[], componentName: string, includeAria: boolean = true): string => {
	let sectionIndex = 0;

	const getSemanticTag = (obj: any, index: number): { tag: string; role?: string } => {
		if (obj.semanticType === 'header') return { tag: 'header', role: 'banner' };
		if (obj.semanticType === 'nav') return { tag: 'nav', role: 'navigation' };
		if (obj.semanticType === 'main') return { tag: 'main', role: 'main' };
		if (obj.semanticType === 'footer') return { tag: 'footer', role: 'contentinfo' };
		if (obj.semanticType === 'aside') return { tag: 'aside', role: 'complementary' };

		// Auto-detect semantic meaning
		if (index === 0) return { tag: 'header', role: 'banner' };
		if (obj.type === 'text' && obj.fontSize > 24) return { tag: 'h2' };
		if (obj.type === 'text' && obj.fontSize > 18) return { tag: 'h3' };
		if (obj.objects && obj.objects.length > 2) {
			sectionIndex += 1;
			return { tag: 'section', role: undefined };
		}
		if (obj.type === 'text') return { tag: 'p' };

		return { tag: 'div' };
	};

	const renderObject = (obj: any, index: number, depth: number = 0): string => {
		const id = generateId('el');
		const { tag, role } = getSemanticTag(obj, index);
		const className = obj.type === 'text' ? `text-${index}` : `box-${index}`;
		const ariaLabel = includeAria && obj.ariaLabel ? ` aria-label="${obj.ariaLabel}"` : '';
		const ariaRole = includeAria && role ? ` role="${role}"` : '';

		if (obj.type === 'text') {
			return `<${tag} class="${className}"${ariaLabel}${ariaRole}>${obj.text || 'Text'}</${tag}>`;
		}

		if (obj.type === 'rect' || obj.type === 'group') {
			const children = obj.objects
				? obj.objects.map((child: any, i: number) => renderObject(child, i, depth + 1)).join('\n      ')
				: '';

			return children
				? `<${tag} class="${className}"${ariaLabel}${ariaRole}>\n      ${children}\n    </${tag}>`
				: `<${tag} class="${className}"${ariaLabel}${ariaRole}></${tag}>`;
		}

		return '';
	};

	const elements = objects.map((obj, index) => renderObject(obj, index)).join('\n    ');

	return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Generated by AI UI Generator">
  <title>${componentName}</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="print.css" media="print">
</head>
<body>
  <main class="container" role="main">
    ${elements}
  </main>
</body>
</html>`;
};

/**
 * Generate CSS from Fabric.js objects with custom properties and responsive media queries
 */
const generateHTMLCSS = (objects: any[]): string => {
	const generateObjectCSS = (obj: any, index: number): string => {
		const css = fabricToCSS(obj);
		const selector = obj.type === 'text' ? `.text-${index}` : `.box-${index}`;
		return `${selector} {\n${cssObjectToString(css)}\n}\n`;
	};

	const objectStyles = objects.map((obj, index) => generateObjectCSS(obj, index)).join('\n');

	return `/* CSS Custom Properties (Design Tokens) */
:root {
  --color-primary: #3b82f6;
  --color-secondary: #6366f1;
  --color-text: #1f2937;
  --color-background: #ffffff;
  --spacing-xs: 0.5rem;
  --spacing-sm: 1rem;
  --spacing-md: 1.5rem;
  --spacing-lg: 2rem;
  --spacing-xl: 3rem;
  --border-radius-sm: 0.25rem;
  --border-radius-md: 0.5rem;
  --border-radius-lg: 1rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
}

/* Reset and base styles */
*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  line-height: 1.6;
  color: var(--color-text);
  background: var(--color-background);
}

/* Container */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--spacing-lg);
}

/* Component styles */
${objectStyles}

/* Responsive media queries */
@media (max-width: 1024px) {
  :root {
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
  }
  
  .container {
    max-width: 100%;
    padding: var(--spacing-md);
  }
}

@media (max-width: 768px) {
  :root {
    --spacing-lg: 1rem;
    --spacing-xl: 1.5rem;
  }
  
  html {
    font-size: 14px;
  }
  
  .container {
    padding: var(--spacing-sm);
  }
}

@media (max-width: 480px) {
  html {
    font-size: 13px;
  }
  
  .container {
    padding: var(--spacing-xs);
  }
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-text: #f3f4f6;
    --color-background: #1f2937;
  }
}
`;
};

/**
 * Generate print stylesheet
 */
const generatePrintCSS = (): string => {
	return `/* Print stylesheet */
@media print {
  body {
    color: #000;
    background: #fff;
  }
  
  .container {
    max-width: 100%;
    padding: 0;
  }
  
  /* Hide non-essential elements */
  nav,
  aside,
  button {
    display: none;
  }
  
  /* Optimize for printing */
  * {
    background: transparent !important;
    box-shadow: none !important;
  }
  
  a[href]::after {
    content: " (" attr(href) ")";
  }
  
  /* Page breaks */
  h2, h3 {
    page-break-after: avoid;
  }
  
  section {
    page-break-inside: avoid;
  }
}
`;
};

/**
 * Export design as HTML code
 */
export const exportHTML = (design: any, options: ExportOptions): ExportedCode => {
	const componentName = kebabToCamel(design.metadata?.screenName || 'generated-page');
	const objects = design.design?.objects || [];

	const htmlCode = generateHTML(objects, componentName, true);
	const cssCode = generateHTMLCSS(objects);
	const printCSSCode = generatePrintCSS();

	const files: ExportedCode['files'] = [
		{
			path: 'index.html',
			content: formatCode(htmlCode),
			language: 'html',
		},
		{
			path: 'styles.css',
			content: formatCode(cssCode),
			language: 'css',
		},
		{
			path: 'print.css',
			content: formatCode(printCSSCode),
			language: 'css',
		},
	];

	return {
		files,
		dependencies: {},
		instructions:
			'Open index.html in a web browser to view your design. The HTML uses semantic elements and includes ARIA attributes for accessibility.',
	};
};
